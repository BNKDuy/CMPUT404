<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:,">
    <title>Clock App</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        header {
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 4rem;
            color: #333;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5fa;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /*
            The code for the main selector below was generated by OpenAI, ChatGPT 4o
            Prompt: How do I style the main section of a clock app in CSS so that I can have 2 sections per row? - 2024-10-12
        */
        main {
            display: grid;
            grid-template-columns: repeat(2, minmax(300px, 1fr));
            gap: 16px;
            align-items: start;
            justify-items: center; 
        }

        .card {
            background-color: #fff;
            width: 45vw;
            height: 40vh;
            border-radius: 10px;
            padding: 8vw;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;           
            flex-direction: column; 
            justify-content: center; 
            align-items: center;    
        }

        h2 {
            font-size: 2.8rem;
            color: #111;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        time {
            font-size: 2.4rem;
            color: #333;
        }

        label {
            font-size: 1.6rem;
            color: #333;
        }

        input {
            font-size: 1.6rem;
            color: #333;
        }

        #timer-checkbox {
            height: 1.6rem;
            width: 1.6rem;
        }

        .timer-checkbox-section {
            margin-top: 1rem;
        }

        output {
            font-size: 1.6rem;
            color: #333;
            margin-bottom: 1rem;
        }

        button {
            font-size: 1.2rem;
            font-weight: bold;
            background-color: #f5f5fa;
            height: 2rem;
            width: 6rem;
            border-radius: 5px;
            border: solid 1px #333;
        }

        .button {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        #clock-section {
            background-color: #d8eedf;
        }
        
        #timer-section {
            background-color: #d8e5f7;
        }

        #timer-message {
            font-size: 1.6rem;
            color: #f00;
            margin-bottom: 1rem;
        }
        
        #stopwatch-section {
            background-color: #fdf1c9;
        }
        
        #countdown-section {
            background-color: #fedcdb;
        }

        #countdown-message {
            font-size: 1.6rem;
            color: #f00;
            margin-bottom: 1rem;
        }

        .countdown-hidden-message {
            display: none;
        }

        @media (max-width: 600px) {
            main {
                display: grid;
                grid-template-columns: repeat(1, minmax(300px, 1fr));
                gap: 16px;
                align-items: start;
            }

            .card {
                width: 80vw;
            }

            h1 {
                font-size: 2em;
            }
        
            h2 {
                font-size: 1.5em;
            }
        
            time, output {
                font-size: 2em;
            }
        }
    
    </style>

    <script>
        'use strict';

        /*
            Lisen for when the page is fully loaded and then call the main function
            The main in the the brackets is the reference to main function that is called when the page is fully loaded
        */
        window.addEventListener('load', main);

        function main() {
            /*
                For this lab, we need to create 4 distinct clock functionalities: a clock, a timer, a stopwatch, and a countdown.
                Each of these functionalities will be implemented as a separate class with its own set of properties and methods.
            */
            const clock = new Clock();
            const timer = new Timer();
            const stopwatch = new Stopwatch();
            const countdown = new Countdown();

            /*
                -   Ticker is a singleton class that is responsible for updating all the clock functionalities every second.
                -   It uses the observer pattern to notify each clock functionality to update itself.
                -   Clock, timer, stopwatch, and countdown will be the observers of the Ticker.
                -   Every second, the Ticker will notify each observer to update itself and change the time display accordingly.
                -   This ensures that all clock functionalities are in sync and update at the same time.
            */
            const ticker = Ticker.getInstance();

            /*
                -   Add the clock functionalities as observers to the Ticker.
                -   This will allow the Ticker to notify each observer to update itself every second.
                -   This is very important because in order to update at the same time, 
                all of them need to have a reference to something that will notify them when to update. That is the Ticker.
            */
            ticker.addObserver(clock);
            ticker.addObserver(timer);
            ticker.addObserver(stopwatch);
            ticker.addObserver(countdown);

            // Start the ticker
            ticker.start();
        }

        class Ticker {
            constructor() {
                /*
                    The if statement below was generated by OpenAI, ChatGPT 4o
                    Prompt: For singleton design in Javascript, how do i know that the object is already created? - 2024-10-12
                    The variable from the answer was modified to fit the variable name that was used in the code.
                */
                if (Ticker.instance) {
                    throw new Error('Ticker is a singleton class.');
                }

                /*
                    The ticker class is responsible for updating all the clock functionalities every second.
                    It uses the observer pattern to notify each observer to update itself.
                    The observers are the clock, timer, stopwatch, and countdown functionalities.
                    There are 4 observers in total (which is more than 1).
                    We will use an array to store all the observers that need to be updated.
                */
                this.observers = [];

                // isTicking is a boolean variable that keeps track of whether the ticker is running or not
                // This will be used to make sure that there is only 1 setTimeout running at a time and it cannot be started multiple times
                // by calling the start method multiple times
                this.isTicking = false;

                /*
                    The timeoutId is a variable that stores the id of the setTimeout function.
                    This will be used to make sure that there is only 1 setTimeout running at a time.
                    It will be set to null at the start because there is no setTimeout running at the start.
                */
                this.timeoutId = null;
            }

            static getInstance() {
                /*
                    The if statement below was generated by OpenAI, ChatGPT 4o
                    Prompt: For singleton design in Javascript, how do i know that the object is already created? - 2024-10-12
                    The variable from the answer was modified to fit the variable name that was used in the code.
                */
                if (!Ticker.instance) {
                    Ticker.instance = new Ticker();
                }
                return Ticker.instance;
            }

            addObserver(observer) {
                /*
                    Since the Ticker is responsible for updating more than one clock functionality,
                    it uses an array to store all the observers that need to be updated.
                    This array is called observers.
                    The addObserver method is used to add an observer to the array of observers.
                    push method is used to add the observer to the array.
                */
                this.observers.push(observer);
            }

            start() {
                /*
                    The start method is used to start the ticker.
                    It will start the ticker only if it is not already running.
                    If the ticker is not running, it will set isTicking to true and call the tick method.
                    This will start the process of updating all the observers every second.
                */
                // This if statement is used to make sure that there is only 1 setTimeout running at a time
                if (!this.isTicking) {
                    this.isTicking = true;
                    this.tick();
                }
            }

            tick() {
                /*
                    When the tick method is called, it will notify each observer to update itself.
                    This is done by calling the update method of each observer.
                    This will update the time display of each clock functionality.
                    This will be done every second to make sure that all clock functionalities are in sync.
                */
                for (let observer of this.observers) {
                    observer.update();
                }

                /*
                    Since I have to make sure that there is only 1 setTimeout running at a time, 
                    I will only call setTimeout again if the previous one has finished.
                    This can be done by calling tick again (which will trigger another 1000 miliseconds timeout) in the setTimeout callback.
                */
                this.timeoutId = setTimeout(() => this.tick(), 1000);
            }
        }

        class Clock {
            /*
                -   The clock class is responsible for displaying the current time in the format HH:MM:SS.
                -   It only has 2 things on display which are the title (a h2 element) and the time.
                -   Since the title is fixed, we only need to update the time every second.
                -   In constructor, we get the reference to the clock-display element which will be used to display time
                -   By getting the reference to the clock-display element, we can use it later to update the clock display when we need it
            */
            constructor() {
                this.clockDisplay = document.getElementById('clock-display');
            }

            /*
                -   The update method is called every second by the Ticker.
                -   Every second, the ticker will call the update method of each observer.
                Therefore, the update method of the clock will be called.
                -   Everytime the update method is called, it gets the current time and updates the clock display with the current time.
                -   The time is displayed in the format HH:MM:SS.
            */
            update() {
                const now = new Date();
                this.clockDisplay.textContent = now.toLocaleTimeString();
            }
        }

        class Timer {
            constructor() {
                /*
                    -   The timer class is responsible for displaying the time left in the format MM:SS.
                    -   It has 5 things on display which are the title (a h2 element), the minutes input, the seconds input, the timer checkbox, and the timer message.
                        +   The title is fixed and does not change.
                        +   The minutes input is used to input the minutes for the timer.
                        +   The seconds input is used to input the seconds for the timer.
                        +   The timer checkbox is used to start and stop the timer.
                        +   The timer message is used to display a message when the time is up. This is hidden by default. It will only be displayed when the time is up.
                    -   In the constructor, we get the reference to the minutes and seconds input fields, the timer checkbox, and the timer message.
                    -   By getting the reference to these elements, we can use them later to start, stop, and reset the timer, and update the timer display when we need it.
                */
                this.minutesInput = document.getElementById('minutes');
                this.secondsInput = document.getElementById('seconds');
                this.timerCheckbox = document.getElementById('timer-checkbox');
                this.timerMessage = document.getElementById('timer-message');

                // isRunning is a boolean variable that keeps track of whether the timer is running or not
                // This will be used by update method to determine if the timer should be updated
                this.isRunning = false;

                /*
                    -   Bind event listeners to the timer checkbox.
                    -   The timer checkbox now listens for a change event.
                    -   When the timer checkbox is checked, the timer is started.
                    -   When the timer checkbox is unchecked, the timer is stopped.
                */
                this.timerCheckbox.addEventListener('change', () => {
                    // this.timerCheckbox.checked returns true if the checkbox is checked and false if it is unchecked
                    // If the checkbox is checked, both the minutes and seconds input fields are disabled by setting disabled to true
                    // This is because the timer is running and the user should not be able to change the minutes and seconds while the timer is running
                    // If the checkbox is unchecked, both the minutes and seconds input fields are enabled by setting disabled to false
                    // This is because the timer is not running and the user should be able to change the minutes and seconds
                    // The isRunning variable is updated to reflect the state of the timer when the checkbox is checked, it will be true which indicates that the timer is running
                    // When the checkbox is unchecked, the isRunning variable is updated to false which indicates that the timer is not running
                    this.minutesInput.disabled = this.timerCheckbox.checked;
                    this.secondsInput.disabled = this.timerCheckbox.checked;
                    this.isRunning = this.timerCheckbox.checked;

                    // If the timer checkbox is checked, get the minutes and seconds from the input fields and calculate the time left
                    // The time left is calculated by multiplying the minutes by 60 and adding the seconds
                    if (this.timerCheckbox.checked) {
                        // The 2 lines below were generated by OpenAI, ChatGPT 4o
                        // Prompt: How do I get the minutes and seconds from the input fields in JavaScript? - 2024-10-12
                        const minutes = parseInt(this.minutesInput.value, 10) || 0;
                        const seconds = parseInt(this.secondsInput.value, 10) || 0;

                        // The time left is calculated by multiplying the minutes by 60 and adding the seconds
                        this.timeLeft = minutes * 60 + seconds;

                        // If the time left is 0, the timer should not run
                        // The user shouldn't be able to start the timer if the time left is 0
                        // The timer checkbox should be unchecked
                        // The minutes and seconds input fields should be enabled so that the user can input a valid time
                        // The isRunning variable should be set to false to indicate that the timer is not running so that the update method does not update the time left
                        if (this.timeLeft === 0) {
                            this.isRunning = false;
                            this.timerCheckbox.checked = false;
                            this.minutesInput.disabled = false;
                            this.secondsInput.disabled = false;
                        }
                    }
                    else {
                        // If the timer checkbox is unchecked, the timer is not running
                        // The minutes and seconds input fields are enabled so that the user can input a valid time
                        // Set the isRunning variable to false to indicate that the timer is not running so that the update method does not update the time left
                        this.timerMessage.textContent = '';
                        this.isRunning = false;
                        this.minutesInput.disabled = false;
                        this.secondsInput.disabled = false;
                    }
                });
            }

            update() {
                // Check if the timer is running
                // If not, do nothing because the time should not be updated it should stay the same
                if (this.isRunning) {
                    // if the timer is running, decrement the time left by 1 second to simulate the timer running
                    this.timeLeft--;

                    // Check if the time is up
                    // If the time is up, update the isRunning variable to false to indicate that the timer is not currently running. This will prevent the timer from running further
                    // When the time is up and user has not uncheck the box, display a message to indicate that the time is up
                    if (this.timeLeft <= 0 && this.timerCheckbox.checked) {
                        this.isRunning = false;
                        this.timerMessage.textContent = 'Time\'s Up!';
                    }
                    
                    // Update the minutes and seconds input fields with the new time left
                    // Calculate the minutes and seconds from the time left
                    // We can get the minutes by dividing the time left by 60
                    // We can get the seconds by taking the remainder of the time left divided by 60
                    const minutes = Math.floor(this.timeLeft / 60);
                    const seconds = this.timeLeft % 60;

                    // Using the reference to the minutes and seconds input fields we got in the constructor, we update the input fields with the new minutes and seconds
                    this.minutesInput.value = minutes;
                    this.secondsInput.value = seconds;
                }
                return;
            }
        }

        class Stopwatch {
            constructor() {
                /*
                    -   The stopwatch class is responsible for displaying the elapsed time in the format HH:MM:SS:SSS.
                    -   It only has 5 things on display which are the title (a h2 element), the time, and 3 buttons (start, stop, reset).
                        +   The title is fixed and does not change.
                        +   The time is displayed in the format HH:MM:SS:SSS. This is the elapsed time of the stopwatch. It starts at 00:00:00:000.
                        This is the only element that changes every second.
                        +   The start button is used to start the stopwatch.
                        +   The stop button is used to stop the stopwatch.
                        +   The reset button is used to reset the stopwatch to 00:00:00:000.
                    -   In the constructor, we get the reference to the stopwatch-display element, and the start, stop, and reset buttons.
                    -   By getting the reference to these elements, we can use them later to start, stop, and reset the stopwatch, and update the stopwatch display when we need it.
                */
                this.stopwatchDisplay = document.getElementById('stopwatch-section').querySelector('time');
                this.startButton = document.getElementById('stopwatch-start-button');
                this.stopButton = document.getElementById('stopwatch-stop-button');
                this.resetButton = document.getElementById('stopwatch-reset-button');

                /*
                    -   The stopwatch starts at 00:00:00:000, so there is no need to reset. The reset button is disabled at the start.
                    -   The stopwatch is not running at the start, so the stop button is disabled at the start.
                */
                this.stopButton.disabled = true;
                this.resetButton.disabled = true;

                /*
                    -   isRunning is a boolean variable that keeps track of whether the stopwatch is running or not. 
                    This will be used by update method to determine if the stopwatch should be updated.
                    -   The stopwatch is not running at the start, so the isRunning variable is set to false.
                    -   The elapsedTime variable is used to store the total elapsed time in milliseconds. This will 
                    be used to display the elapsed time in the stopwatch.
                    -   The elapsedTime is set to 0 at the start because the stopwatch starts at 00:00:00:000.
                    -   The lastStartTime variable is used to store the timestamp when the stopwatch was last started. 
                    This will be used to calculate the elapsed time. It is very important to keep track of the last start time 
                    because the stopwatch can be stopped and started multiple times.
                    -   The lastStartTime is set to 0 at the start because the stopwatch is not running at the start.
                */
                this.isRunning = false;
                this.elapsedTime = 0;
                this.lastStartTime = 0;

                /*
                    -   Bind event listeners to the start buttons.
                    -   The start button now listens for a click event. When the start button is clicked, the stopwatch is started.
                    -   The start button is disabled when the stopwatch is started because the stopwatch is already running.
                    -   The stop button is enabled when the stopwatch is started because the stopwatch can be stopped.
                    -   The reset button is enabled when the stopwatch is started because the stopwatch can be reset since the time is
                    no longer 00:00:00:000. 
                    -   Set the lastStartTime to the current time when the start button is clicked. This is the time when the stopwatch was last started.
                    Since this might not be the first time the stopwatch is started, we need to keep track of the last start time.
                    -   The isRunning variable is set to true when the start button is clicked because the stopwatch is now running.
                    So the update method will update the stopwatch display every second.
                */
                this.startButton.addEventListener('click', () => {
                    this.isRunning = true;
                    this.lastStartTime = Date.now();
                    this.startButton.disabled = true;
                    this.stopButton.disabled = false;
                    this.resetButton.disabled = false;
                });

                /*
                    -   Bind event listeners to the stop buttons.
                    -   The stop button now listens for a click event. When the stop button is clicked, the stopwatch is stopped.
                    -   The stop button is disabled when the stopwatch is stopped because the stopwatch is no longer running.
                    -   The start button is enabled when the stopwatch is stopped because the stopwatch can be started again.
                    -   The reset button is enabled when the stopwatch is stopped because the stopwatch can be reset since the time is
                    no longer 00:00:00:000. 
                    -   The isRunning variable is set to false when the stop button is clicked because the stopwatch is no longer running.
                    So the update method will not update the stopwatch display every second.

                */
                this.stopButton.addEventListener('click', () => {
                    this.isRunning = false;
                    this.stopButton.disabled = true;
                    this.startButton.disabled = false;
                    this.resetButton.disabled = false;
                });

                /*
                    -   Bind event listeners to the reset buttons.
                    -   The reset button now listens for a click event. When the reset button is clicked, the stopwatch is reset.
                    -   The reset button is disabled when the stopwatch is reset because the stopwatch is no longer running.
                    -   The start button is enabled when the stopwatch is reset because the stopwatch can be started again.
                    -   The stop button is disabled when the stopwatch is reset because the stopwatch is no longer running.
                    -   The isRunning variable is set to false when the reset button is clicked because the stopwatch is no longer running.
                    So the update method will not update the stopwatch display every second.
                    -   The elapsedTime is set to 0 when the reset button is clicked because the stopwatch is reset to 00:00:00:000.
                    -   The stopwatch display is updated to 00:00:00:000 when the reset button is clicked.
                */
                this.resetButton.addEventListener('click', () => {
                    this.isRunning = false;
                    this.elapsedTime = 0;
                    this.resetButton.disabled = true;
                    this.stopButton.disabled = true;
                    this.startButton.disabled = false;
                    this.stopwatchDisplay.textContent = '0:00:00:000';
                });
            }

            /*
                -   The update method is called every second by the Ticker.
                -   Every second, the ticker will call the update method of each observer.
                Therefore, the update method of the stopwatch will be called.
                -   The update method is responsible for updating the stopwatch display every second.
                -   The stopwatch display is updated with the elapsed time in the format HH:MM:SS:SSS.
                -   The elapsed time is calculated by taking the difference between the current time and the last start time.
                -   The elapsed time is then formatted in the format HH:MM:SS:SSS and displayed in the stopwatch display.
                -   The last start time is updated to the current time so that the next elapsed time can be calculated correctly.
            */
            update() {
                // Check if the stopwatch is running
                // If not, do nothing because the time should not be updated it should diplay the time that it is stop at
                if (!this.isRunning) return;

                // Calculate the elapsed time since the last update
                // Get the current time
                // Calculate the difference between the current time and the last start time in milliseconds
                // Add the difference to the total elapsed time
                // This elapsed time will be used to calculate the hours, minutes, seconds, and milliseconds
                // And then format the time display
                const now = Date.now();
                this.elapsedTime += now - this.lastStartTime;
                this.lastStartTime = now;
                const totalMilliseconds = this.elapsedTime;

                // Calculate the hours, minutes, seconds, and milliseconds
                // 1 second = 1000 milliseconds
                // 1 minute = 60 seconds = 60 * 1000 = 60000 milliseconds
                // 1 hour = 60 minutes = 60 * 60000 = 3600000 milliseconds
                const milliseconds = totalMilliseconds % 1000;
                const seconds = Math.floor((totalMilliseconds % 60000) / 1000);
                const minutes = Math.floor((totalMilliseconds % 3600000) / 60000);
                const hours = Math.floor(totalMilliseconds / 3600000);

                /* 
                    The code below was generated by OpenAI, ChatGPT o1-preview
                    Prompt: How do i display time for a stopwatch in JavaScript in this format h:mm:ss.sss? - 2024-10-12
                    The variable from the asnwer was modified to fit the variable name that was used in the code.
                */
                // Format the time display
                const formattedTime = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;

                // Using the reference to the stopwatch display we got in the constructor, we update the stopwatch display with the formatted time
                this.stopwatchDisplay.textContent = formattedTime;
            }
        }

        class Countdown {
            constructor() {
                /*
                    -   The countdown class is responsible for displaying the time remaining until a specific date and time.
                    -   It has 5 things on display which are the title (a h2 element), the countdown output, the date input, the time input, and 2 buttons (start, cancel).
                        +   The title is fixed and does not change.
                        +   The countdown output is used to display the time remaining until the specific date and time.
                        +   The date input is used to input the date for the countdown.
                        +   The time input is used to input the time for the countdown.
                        +   The start button is used to start the countdown.
                        +   The cancel button is used to cancel the countdown.
                    -   There is also a countdown message that is displayed when the countdown is over. This is hidden by default.
                    -   In the constructor, we get the reference to the countdown output, the date input, the time input, the start button, and the cancel button.
                    -   By getting the reference to these elements, we can use them later to start, cancel, and update the countdown display when we need it.
                */
                this.dateInput = document.getElementById('countdown-date-input');
                this.timeInput = document.getElementById('countdown-time-input');
                this.startButton = document.getElementById('countdown-start-button');
                this.cancelButton = document.getElementById('countdown-cancel-button');
                this.countdownDisplay = document.getElementById('countdown-output');
                this.countdownMessage = document.getElementById('countdown-message');
        
                // isRunning is a boolean variable that keeps track of whether the countdown is running or not
                // This will be used by update method to determine if the countdown should be updated
                this.isRunning = false;

                // endTime is a variable that stores the end time for the countdown
                // This will be used to calculate the time remaining for the countdown
                // The endTime is set to 0 at the start because the countdown has not started yet
                this.endTime = 0;
        
                // Bind event listeners to the start and cancel buttons
                // The start button listens for a click event. When the start button is clicked, the countdown is started.
                // The cancel button listens for a click event. When the cancel button is clicked, the countdown is canceled.
                this.startButton.addEventListener('click', () => this.startCountdown());
                this.cancelButton.addEventListener('click', () => this.cancelCountdown());
            }
        
            startCountdown() {
                // The block of code below was generated by OpenAI, ChatGPT o1-mini
                // Prompt: How do I validate a date and time input from html input to javascript to make sure that the date is valid and the time is in the future? - 2024-10-12
                // The variable from the asnwer was modified to fit the variable name that was used in the code.
                //---------------------- ChatGPT code starts here ----------------------
                /*
                    My explanation of the code below:
                    -   The user will input a date and time for the countdown.
                    -   The date and time will be validated to ensure that they are valid and in the future.
                    -   If the date and time are valid and in the future, the countdown will start.
                    -   If the date and time are not valid or not in the future, an alert will be shown to the user.
                    -   Since date and time are seperate inputs, they need to be combined into a single Date object.
                    That can later be used to calculate the time remaining for the countdown.
                */

                // Get the date and time values from the input fields
                const dateValue = this.dateInput.value;
                const timeValue = this.timeInput.value || '00:00'; // Default to midnight if time not selected

                // Validation: Ensure a date is selected
                if (!dateValue) {
                    alert('Please select a valid date.');
                    return;
                }
        
                // Combine date and time into a single Date object
                const combinedDateTime = new Date(`${dateValue}T${timeValue}`);
        
                // Validation: Check if the combined date and time are valid
                if (isNaN(combinedDateTime.getTime())) {
                    alert('Please select a valid date and time.');
                    return;
                }
        
                const now = new Date();
        
                // Validation: Ensure the selected date and time are in the future
                if (combinedDateTime <= now) {
                    alert('Please select a future date and time.');
                    return;
                }

                // Set the end time for the countdown
                this.endTime = combinedDateTime.getTime();
                //---------------------- ChatGPT code ends here ----------------------
        
                // Set isRunning to true to indicate that the countdown is running so that the update method will update the countdown display everytime the clock ticks
                this.isRunning = true;
        
                // Disable the start button and enable the cancel button
                // When we reach this part, the count down is running
                // This is to prevent the user from starting the countdown multiple times
                // The user can cancel the countdown if needed since now the countdown is running
                this.startButton.disabled = true;
                this.cancelButton.disabled = false;

                // Disable the date and time input fields
                // The user should not be able to change the date and time while the countdown is running
                this.dateInput.disabled = true;
                this.timeInput.disabled = true;
        
                // Make sure the countdown display is reset. For consistency, this will only be set by the update method
                // the update method has the functionality to calculate the time left and display it.
                this.countdownDisplay.textContent = '';
            }
        
            cancelCountdown() {
                // Stop the countdown
                this.isRunning = false;
                this.cancelButton.disabled = true;
                this.startButton.disabled = false;
                this.countdownDisplay.textContent = '';
        
                // Re-enable the input fields
                this.dateInput.disabled = false;
                this.timeInput.disabled = false;
                
                // Hide the countdown is over message
                // This message was originally hidden by by the class countdown-hidden-message display property set to none
                // When the countdown is over, it will be display by remove the class countdown-hidden-message to show the message
                // When the countdown is canceled, the message should be hidden again
                // This is done by adding the class countdown-hidden-message to the countdown message
                // Which will set the display property to none and hide the message
                this.countdownMessage.classList.add('countdown-hidden-message');
            }
        
            update() {
                if (this.isRunning) {
                    // We need to get the time left for the countdown in milliseconds
                    // The time left is the difference between the end time and the current time
                    const now = Date.now();
                    const timeLeft = this.endTime - now;

                    // Unlike the stopwatch, we are not interested in milliseconds
                    // We are interested in years, months, days, hours, minutes, and seconds
                    // So we need to convert the time left in milliseconds to seconds, minutes, hours, days, months, years.
                    // 1 second = 1000 milliseconds so we divide the time left by 1000 to get the time left in seconds
                    // I decided to use Math.abs to get the absolute value of the time left here so I can get the absolute value of the time left
                    // and keep the time left as it is (it can be negative or positive) so later I can use it to determine if the countdown is 
                    // counting down to a specific date and time or counting away from it
                    let diffInSeconds = Math.floor(Math.abs(timeLeft) / 1000);

                    // If the time left is greater than 0, we add 1 to the diffInSeconds
                    // During testing, I noticed that the time left was always 1 second less than the actual time left
                    // My assumption is that the time left is always rounded down to the nearest second that is why it is missing 1 second
                    // So I added 1 to the diffInSeconds to get the actual time left
                    // When the time left is 0, the diffInSeconds will be 0 so we don't need to add 1
                    // When the time left is less than 0, the timeleft will be rounded down to the nearest second, so when we get the absolute value
                    // of the time left, it will be 1 second more than the actual time left so we don't need to add 1
                    if (timeLeft > 0) {
                        diffInSeconds += 1;
                    }
        
                    /*
                        Calculate the number of years, months, days, hours, minutes, and seconds from the time left in seconds
                        This will be used to display the countdown in the format " X years X months X days X hours X minutes X seconds (remaining/ago)"
                        Number of seconds from each unit:
                        - 1 minute = 60 seconds
                        - 1 hour = 60 minutes = 60 * 60 = 3600 seconds
                        - 1 day = 24 hours = 24 * 3600 = 86400 seconds
                        - 1 month = 30 days = 30 * 86400 = 2592000 seconds (For simplicity, we assume each month has 30 days)
                        - 1 year = 12 months = 12 * 2592000 = 31104000 seconds (For simplicity, we assume each year has 12 months with each month having 30 days)
                    */

                    // Calculate the number of years
                    // According to the above calculation, 1 year is equal to 31104000 seconds
                    // So we divide the time left by 31104000 to get the number of years. The number is not even so we use Math.floor to get the whole number 
                    // since we are not interested in the decimal part
                    const years = Math.floor(diffInSeconds / 31104000);

                    // We get the remainder of the time left divided by 31104000 to get the remaining seconds
                    // We use remainder because we already calculated the number of years so we don't need to include them in the remaining seconds
                    // This remaining seconds will be the number seconds that is not covered by the years
                    // This remaining seconds will be used to calculate the number of months, days, hours, minutes, and seconds
                    diffInSeconds %= 31104000;

                    // Calculate the number of months
                    // According to the above calculation, 1 month is equal to 2592000 seconds
                    // So we divide the remaining seconds by 2592000 to get the number of months. The number is not even so we use Math.floor to get the whole number
                    // since we are not interested in the decimal part
                    const months = Math.floor(diffInSeconds / 2592000);

                    // We get the remainder of the remaining seconds divided by 2592000 to get the remaining seconds
                    // We use remainder because we already calculated the number of months so we don't need to include them in the remaining seconds
                    // This remaining seconds will be the number seconds that is not covered by the months
                    // This remaining seconds will be used to calculate the number of days, hours, minutes, and seconds
                    diffInSeconds %= 2592000;

                    // Calculate the number of days
                    // According to the above calculation, 1 day is equal to 86400 seconds
                    // So we divide the remaining seconds by 86400 to get the number of days. The number is not even so we use Math.floor to get the whole number
                    // since we are not interested in the decimal part
                    const days = Math.floor(diffInSeconds / 86400);

                    // We get the remainder of the remaining seconds divided by 86400 to get the remaining seconds
                    // We use remainder because we already calculated the number of days so we don't need to include them in the remaining seconds
                    // This remaining seconds will be the number seconds that is not covered by the days
                    // This remaining seconds will be used to calculate the number of hours, minutes, and seconds
                    diffInSeconds %= 86400;

                    // Calculate the number of hours
                    // According to the above calculation, 1 hour is equal to 3600 seconds
                    // So we divide the remaining seconds by 3600 to get the number of hours. The number is not even so we use Math.floor to get the whole number
                    // since we are not interested in the decimal part
                    const hours = Math.floor(diffInSeconds / 3600);

                    // We get the remainder of the remaining seconds divided by 3600 to get the remaining seconds
                    // We use remainder because we already calculated the number of hours so we don't need to include them in the remaining seconds
                    // This remaining seconds will be the number seconds that is not covered by the hours
                    // This remaining seconds will be used to calculate the number of minutes and seconds
                    diffInSeconds %= 3600;

                    // Calculate the number of minutes
                    // According to the above calculation, 1 minute is equal to 60 seconds
                    // So we divide the remaining seconds by 60 to get the number of minutes. The number is not even so we use Math.floor to get the whole number
                    // since we are not interested in the decimal part
                    const minutes = Math.floor(diffInSeconds / 60);

                    // We get the remainder of the remaining seconds divided by 60 to get the remaining seconds
                    // We use remainder because we already calculated the number of minutes so we don't need to include them in the remaining seconds
                    // This remaining seconds will be the number seconds that is not covered by the minutes
                    // This remaining seconds will be used to calculate the number of seconds
                    const seconds = diffInSeconds % 60;
                    
                    // Format the countdown display
                    const formattedTime = `${years} years ${months} months ${days} days ${hours} hours ${minutes} minutes ${seconds} seconds`;
                    
                    // If the time left is greater than 0, it means we are counting down to the specific date and time and we have not reached it yet
                    // If the time left is less than 0, it means we have passed the specific date and time and we are counting away from it
                    if (timeLeft > 0) {
                        this.countdownDisplay.textContent = `${formattedTime} remaining`;
                    }
                    else {
                        // We should display the countdown message to indicate that the countdown is over
                        // The countdown message is hidden by default so we need to remove the hidden class to display it
                        // We use the class selector in css to hide the countdown message with display: none
                        // Therefore, to display the countdown message, we need to remove the hidden class so that display:none will be removed
                        this.countdownMessage.classList.remove('countdown-hidden-message');
                        this.countdownDisplay.textContent = `${formattedTime} ago`;
                    }
                }
            }
        }
    </script>
</head>
<body>
    <header>
        <h1>Clock App</h1>
    </header>

    <main>
        <!-- Clock Section -->
        <section id="clock-section" class="card">
            <h2>Clock</h2>

            <!-- Time Display Section -->
            <!-- The time display section is used to display the current time in the format HH:MM:SS -->
            <time id="clock-display">00:00:00</time>
        </section>

        <!-- Timer Section -->
        <section id="timer-section" class="card">
            <h2>Timer</h2>
            
            <!-- Timer Message -->
            <output id="timer-message"></output>

            <!-- Minutes Input Section -->
            <!-- The minutes input field is used to input the minutes for the timer -->
            <!-- The minutes has a minimum value of 0 and a maximum value of 59 --> 
            <!-- The default is 0-->
            <section>
                <h3>Time input:</h3>
                <label for="minutes">Minutes:</label>
                <input type="number" id="minutes" min="0" max="59" value="0">
            <!-- Seconds Input Section -->
            <!-- The seconds input field is used to input the seconds for the timer -->
            <!-- The seconds has a minimum value of 0 and a maximum value of 59 -->
            <!-- The default is 0-->
                <label for="seconds">Seconds:</label>
                <input type="number" id="seconds" min="0" max="59" value="0">
            </section>

            <!-- Timer checkbox -->
            <!-- The timer checkbox is used to start and stop the timer -->
            <section class="timer-checkbox-section">
                <h3>Timer control:</h3>
                <label for="timer-checkbox">Timer:</label>
                <input type="checkbox" id="timer-checkbox">
            </section>
        </section>

        <!-- Stopwatch Section -->
        <section id="stopwatch-section" class="card">
            <h2>Stopwatch</h2>
            <time>0:00:00.000</time>

            <!-- Buttons Section -->
            <!-- These button will be use to control the stopwatch functionality -->
            <!-- The start button is used to start the stopwatch -->
            <!-- The stop button is used to stop the stopwatch -->
            <!-- The reset button is used to reset the stopwatch (make the stop watch become 0) -->
            <section class="button">
                <h3>Stopwatch control:</h3>
                <button id="stopwatch-start-button">Start</button>
                <button id="stopwatch-stop-button">Stop</button>
                <button id="stopwatch-reset-button">Reset</button>
            </section>

        </section>

        <!-- Countdown Section -->
        <section id="countdown-section" class="card">
            <h2>Countdown</h2>

            <!-- Countdown Output Section -->
            <!-- The countdown output is used to display the time remaining until the specific date and time -->
            <output id="countdown-output"></output>

            <!-- Countdown Hidden Message -->
            <!-- The countdown message is used to display a message when the countdown is over -->
            <!-- This message is hidden by default and will only be displayed when the countdown is over -->
            <p class="countdown-hidden-message" id="countdown-message">Countdown is over!</p>

           
            <section>
                <h3>Date and Time input:</h3>
                
                <!-- Countdown Date Input Section -->
                <!-- The date input field is used to input the date for the countdown -->
                <label for="countdown-date-input">Select date:</label>
                <input type="date" id="countdown-date-input">

                <!-- Countdown Time Input Section -->
                <!-- The time input field is used to input the time for the countdown -->
                <label for="countdown-time-input">Select time:</label>
                <input type="time" id="countdown-time-input">
            </section>

            <!-- Countdown Buttons Section -->
            <!-- These button will be use to control the countdown functionality -->
            <!-- The start button is used to start the countdown -->
            <!-- The cancel button is used to cancel the countdown (it will stop the current countdown and allow user to change the time) -->
            <section class="button">
                <h3>Countdown control:</h3>
                <button id="countdown-start-button">Start</button>
                <button id="countdown-cancel-button">Cancel</button>
            </section>
        </section>
    </main>
</body>
</html>
